import http.Request;import http.Response;import java.io.UnsupportedEncodingException;import java.util.Arrays;import java.util.concurrent.locks.ReentrantLock;/** * Created by Bernd on 23.11.2015. */public class Container {    public Response response;    public final Request request;    public RequestResolver requestResolver;    public ReentrantLock lock;    // Representiert die Prozentzahlen die noch abgeholt werden m�ssen.    private byte[] check = new byte[]{        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    };    public Container(final Request request) {        this.request = request;        this.lock = new ReentrantLock();    }    /**     * Response muss definitiv geladen sein!     * @param from     * @param to     * @return     */    public byte[] put(int from, int to) {        try {            requestResolver.join();        } catch (InterruptedException e) {            if (response == null) {                response = new Response.InternalServerError();            }            e.printStackTrace();        }        byte[] responseArray;        try {            responseArray = response.getBytes();        } catch (UnsupportedEncodingException e) {            try {                responseArray = new Response.InternalServerError().getBytes();            } catch (UnsupportedEncodingException e1) {                e1.printStackTrace(); // Extrem unwahrscheinlich!                return new byte[0];            }        }        // Abgeholte Felder mit Null bef�llen        for (int i = from; i < to; i++) {            if (check[i] != 1) {                System.err.printf("Byte %d von %s wurde bereits abgeholt\n", i, "KP");            }            check[i] = 0;        }        return Arrays.copyOfRange(responseArray, (int)(((double)from/100) * responseArray.length), (int)(((double)to/100) * responseArray.length));    }    public synchronized boolean hasFinished() {        return Arrays.equals(check, new byte[]{                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        });    }    public void addResolver(Container requestContainer) {        if (requestResolver == null) {            this.requestResolver = new RequestResolver(requestContainer);            this.requestResolver.start();        }    }    public int getBytesBefore(int rangeFrom) {        try {            return (int)(((double)rangeFrom/100) * response.getBytes().length);        } catch (UnsupportedEncodingException e) {            return -1;        }    }}