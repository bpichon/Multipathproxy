import http.Request;import http.Response;import java.io.UnsupportedEncodingException;import java.util.Arrays;import java.util.concurrent.locks.ReentrantLock;/** * Created by Bernd on 23.11.2015. */public class Container {    public Response response;    public final Request request;    public RequestResolver requestResolver;    public ReentrantLock lock;    // Representiert die Prozentzahlen die noch abgeholt werden m�ssen.    private byte[] check = new byte[]{        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    };    public Container(final Request request) {        this.request = request;        this.lock = new ReentrantLock();    }    /**     * Response muss definitiv geladen sein!     * @param from     * @param to     * @return     */    public byte[] put(int from, int to) {        try {            requestResolver.join();        } catch (InterruptedException e) {            if (response == null) {                response = new Response.InternalServerError();            }            e.printStackTrace();        }        byte[] responseArray;        try {            responseArray = response.getBytes();        } catch (UnsupportedEncodingException e) {            try {                responseArray = new Response.InternalServerError().getBytes();            } catch (UnsupportedEncodingException e1) {                e1.printStackTrace(); // Extrem unwahrscheinlich!                return new byte[0];            }        }        // Abgeholte Felder mit Null bef�llen        for (int i = from; i < to; i++) {            if (check[i] != 1) {                System.err.printf("Byte %d von %s wurde bereits abgeholt\n", i, "KP");            }            check[i] = 0;        }        int[] value = getStartAndEnd(from, to , responseArray.length, Main.MAX_HUB_RESPONSE_SIZE);        return Arrays.copyOfRange(responseArray, value[0], value[1]);    }    public synchronized boolean hasFinished() {        return Arrays.equals(check, new byte[]{                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        });    }    public void addResolver(Container requestContainer) {        if (requestResolver == null) {            this.requestResolver = new RequestResolver(requestContainer);            this.requestResolver.start();        }    }    public int getBytesBefore(int rangeFrom, int maxSize) {        int arrayLength = 0;        try {            arrayLength = response.getBytes().length;        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        }        final int byteIndexStart = (int)(((double)rangeFrom/100) * arrayLength);        final int restBefore = byteIndexStart % maxSize;        final int realByteIndexStart;        if (restBefore < maxSize / 2) {            // Die Überschüssigen Bytes müssen in diesem Response mitgesendet werden.            realByteIndexStart = byteIndexStart - restBefore;        } else {            realByteIndexStart = byteIndexStart + (maxSize - restBefore);        }        return realByteIndexStart;    }    public int[] getStartAndEnd(int from, int to, int arrayLength, int maxSize) {        final int realByteIndexStart = getBytesBefore(from, maxSize);        final int byteIndexEnd = (int)(((double)to/100) * arrayLength);        if (to == 100) {            // Überstand muss mitgesendet werden, da letzter Teil.            return new int[]{realByteIndexStart, byteIndexEnd};        }        final int size = byteIndexEnd - realByteIndexStart;        final int realByteIndexEnd;        final int restAfter = size % maxSize;        if (restAfter < maxSize / 2) {            // Diese Antwort hat einen Überstand, der zu klein ist, also wird er im nächsten Response mitgesendet,            // außer das ist die letzte Antwort. (to = 100)            realByteIndexEnd = byteIndexEnd - restAfter;        } else {            realByteIndexEnd = Math.min(                    byteIndexEnd + (maxSize - restAfter),                    arrayLength);        }        return new int[]{realByteIndexStart, realByteIndexEnd};    }}