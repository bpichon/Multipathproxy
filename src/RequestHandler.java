import protocols.CPRequest;import protocols.CPResponse;import java.io.IOException;import java.io.OutputStream;import java.net.Socket;import java.util.Arrays;/** * Created by Bernd on 28.11.2015. */public class RequestHandler implements Runnable {    final Socket mobileSocket;    final private CPRequest request;    final private RequestMonitor monitor;    final private long processingStartTime;    final private long requestArrivalTime;    public RequestHandler(final CPRequest request, final Socket mobileSocket, long processingStartTime) {        this.requestArrivalTime = System.nanoTime();        this.mobileSocket = mobileSocket;        this.request = request;        this.processingStartTime = processingStartTime;        this.monitor = RequestMonitor.getInstance();    }    @Override    public void run() {        OutputStream out;        byte[] response;        try {            out = mobileSocket.getOutputStream();            // out nicht closen!            response = monitor.getResponse(request);        } catch (IOException e) {            e.printStackTrace();            return; // TODO: was hat das f�r Folgen?        } finally {            // Socket nicht closen.        }            int bytesBefore = monitor.getBytesBefore(request);   // ganzzahlig! Und durch Main.MAX_HUB_RESPONSE_SIZE teilbar!            int duration = (int) ((System.nanoTime() - processingStartTime) / 1_000_000); // Nano-Sek to Milli-Sek            // response in mehrere kleinere Responses aufteilen            boolean isLastRange = (request.rangeTo == 100);            boolean isLocalLast;            int partsBefore = bytesBefore / Main.MAX_HUB_RESPONSE_SIZE; // ergebnis ist eigentlich ganzzahlig, da immer vielfache von Main.MAX_HUB_RESPONSE verschickt werden.            int maxParts = (int) Math.ceil(response.length / Main.MAX_HUB_RESPONSE_SIZE); //F�r diese Antwort            int partCounter = 0;            int sendBytes = 0;            while (sendBytes < response.length) {                int chunkedSize = Math.min(response.length - sendBytes, Main.MAX_HUB_RESPONSE_SIZE);                isLocalLast = sendBytes + chunkedSize == response.length;                System.out.printf("Response.length: %d | %d \n", response.length, sendBytes + chunkedSize);                final CPResponse proxyResponse = new CPResponse(                        request.hubRequestId,                        request.part,                        partsBefore + partCounter,                        (isLocalLast) ? ((isLastRange) ? CPResponse.GLOBAL_LAST:CPResponse.LOCAL_LAST) : CPResponse.NOT_LAST,                        (int) (System.nanoTime() - requestArrivalTime) / 1_000_000,         // To Milliseconds                        Arrays.copyOfRange(response, sendBytes, sendBytes + chunkedSize));                partCounter++;                sendBytes += chunkedSize;                try {                    out.write(proxyResponse.getBytes());                    out.flush();                } catch (IOException ex) {                    ex.printStackTrace();                    System.err.println("Verbindung abgebrochen!");                }            }            System.out.printf("\nResponse f�r %d verschickt. \nDauer: " + duration + " \nBytes: " + response.length + " \nSocket: %s\n", request.hubRequestId, mobileSocket.toString());    }}