package protocols;import http.Request;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.text.ParseException;import java.util.Arrays;public class CPRequest {    public static final String BODY_SEPARATOR = "\r\n";    public static final byte[] BODY_SEPARATOR_BYTES = {13, 10};    public static final String HEADER_SEPARATOR = " ";    public static final byte HEADER_SEPARATOR_BYTES = 32;    public String hubId;    public int hubRequestId;    public int rangeFrom;    public int rangeTo;    public int part;    // wird nur zum parsen benötigt.    int lengthByHeader = -1;    private Request request;    public CPRequest() {        this(null, -1, -1, -1, -1, null);    }    public CPRequest(final String hubId, final int hubRequestId, final int rangeFrom, final int rangeTo, final int part, final Request request) {        this.hubId = hubId;        this.hubRequestId = hubRequestId;        this.rangeFrom = rangeFrom;        this.rangeTo = rangeTo;        this.part = part;        this.request = request;    }    /**     *     * @param message     * @return überschüssige Bytes. Oder wenn die message nicht geparst werden konnte, weil zu wenige bytes vorhanden, alles     * @throws ParseException     */    public byte[] parse(final byte[] message) throws ParseException {        final int length = message.length;        final int payloadLength;        final int payloadStart;        for (int i = 0; i < length; i++) {            if (length > (i + 1)                    && message[i] == BODY_SEPARATOR_BYTES[0]                    && message[i + 1] == BODY_SEPARATOR_BYTES[1]) {                final String headerMessage = new String(message, 0, i);                final String[] headerFields = headerMessage.split(HEADER_SEPARATOR);                // PT <length> <hub-id> <hr-id> <from> <to> <part> <HTTP-Request>                lengthByHeader = Integer.parseInt(headerFields[1]);                hubId = headerFields[2];                hubRequestId = Integer.parseInt(headerFields[3]);                rangeFrom = Integer.parseInt(headerFields[4]);                rangeTo = Integer.parseInt(headerFields[5]);                part = Integer.parseInt(headerFields[6]);                // Alle Header Fields geparst.                payloadStart = i + BODY_SEPARATOR_BYTES.length;                payloadLength = lengthByHeader;                if (payloadStart + payloadLength <= length) {                    // Die Nachricht befindet sich komplett im buffer                    final Request tempRequest = new Request();                    byte[] result = tempRequest.parse(message, payloadStart, payloadStart + payloadLength + 1);                    // result müsste null sein!                    if (result != null || tempRequest.content == null) {                        System.err.println("ACHTUNG: Request nicht richtig geparst!");                        break;                    } else {                        // Erfolgreich                        request = tempRequest;                        // den Überschuss zurückliefern                        return Arrays.copyOfRange(message, payloadStart + payloadLength, length);                    }                } else {                    // Nicht genug Bytes im Buffer.                    break;                }            }        }        // Noch nicht mal Header fertig gefunden        return message;    }    public byte[] parse2(final byte[] message, final int length) throws ParseException {        int index = 0;        /* Parse "Header" */        if (lengthByHeader < 0) {            // Header wurde noch nicht geparst            for (int i = index; i < length; i++) {                if (length > (i + 1)                        && message[i] == BODY_SEPARATOR_BYTES[0]                        && message[i + 1] == BODY_SEPARATOR_BYTES[1]) {                    final String headerMessage = new String(message, index, i);                    final String[] headerFields = headerMessage.split(HEADER_SEPARATOR);                    // PT <length> <hub-id> <hr-id> <from> <to> <part> <HTTP-Request>                    lengthByHeader = Integer.parseInt(headerFields[1]);                    hubId = headerFields[2];                    hubRequestId = Integer.parseInt(headerFields[3]);                    rangeFrom = Integer.parseInt(headerFields[4]);                    rangeTo = Integer.parseInt(headerFields[5]);                    part = Integer.parseInt(headerFields[6]);                    if (hubId != null && lengthByHeader >= 0) {                        index = i + BODY_SEPARATOR_BYTES.length;                        break; // Schleife verlassen, wenn header fertig geparst                    }                }            }            if (hubId == null                    || lengthByHeader < 0                    || index + lengthByHeader > length) {                // noch nicht vollständig                return Arrays.copyOfRange(message, index, length);            }        }        /* Parse Response */        if (request == null) {            // Body wurde noch nicht geparst            final Request tempRequest = new Request();            byte[] result = tempRequest.parse(message, index, index + lengthByHeader);            if (result == null) {                request = tempRequest;                // Der Request konnt geparst werden, weil genügend Bytes vorhanden waren.                // Gib überschüssige Bytes zurück                if ((index + lengthByHeader) > message.length) {                    // Es gibt überschüssige Bytes                    return Arrays.copyOfRange(message, index + lengthByHeader, message.length);                }                return new byte[]{};            } else {                // Nicht geschafft, da nicht genug bytes vorhanden waren                return result;            }        }        /* Der request wurde bereits geparst, es wird also das ganze globalbuffer zurückgeliefert. */        return Arrays.copyOfRange(message, 0, length);    }    public byte[] getBytes() {        final ByteArrayOutputStream result = new ByteArrayOutputStream();        try {            final byte[] payload = request.getBytes();            result.write("PR".getBytes(Message.CHARSET));            result.write(HEADER_SEPARATOR_BYTES);            result.write(("" + payload.length).getBytes(Message.CHARSET));            result.write(HEADER_SEPARATOR_BYTES);            result.write(hubId.getBytes(Message.CHARSET));            result.write(HEADER_SEPARATOR_BYTES);            result.write(("" + hubRequestId).getBytes(Message.CHARSET));            result.write(HEADER_SEPARATOR_BYTES);            result.write(("" + rangeFrom).getBytes(Message.CHARSET));            result.write(HEADER_SEPARATOR_BYTES);            result.write(("" + rangeTo).getBytes(Message.CHARSET));            result.write(HEADER_SEPARATOR_BYTES);            result.write(("" + part).getBytes(Message.CHARSET));            /* BODY starts here */            result.write(BODY_SEPARATOR_BYTES);            result.write(payload);        } catch (IOException e) {            e.printStackTrace();        }        return result.toByteArray();    }    public Request getRequest() {        return request;    }}